# -*- coding: utf-8 -*-
"""Actividad 6 - Continuación de Pruebas de raíz unitaria

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1irr41gQrGnLKDwBdWSdOQTrINZepqW_m
"""

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, acf
from statsmodels.graphics.tsaplots import plot_acf
import warnings
warnings.filterwarnings("ignore")

# Define stocks and date range
tickers = ['BLK', 'WMT', 'CRWD', 'JNJ']
start_date = '2019-11-29'
end_date = pd.Timestamp.today().strftime('%Y-%m-%d')

# Fetch stock data with auto_adjust=True (default)
data = yf.download(tickers, start=start_date, end=end_date, auto_adjust=True)['Close']

# Set random seed for reproducibility
np.random.seed(42)

# Loop through each stock
for ticker in tickers:
    # Get stock prices
    prices = data[ticker].dropna()
    returns = prices.pct_change().dropna()

    # 1. Random Walk Simulation
    # Simulate a random walk based on stock's return volatility
    n_steps = len(prices)
    mean_return = returns.mean()
    std_return = returns.std()
    random_steps = np.random.normal(mean_return, std_return, n_steps)
    random_walk = np.cumsum(random_steps) + np.log(prices.iloc[0])
    random_walk = np.exp(random_walk)  # Convert back to price scale

    # Plot actual prices vs random walk
    plt.figure(figsize=(10, 6))
    plt.plot(prices.index, prices, label='Actual Prices', color='blue')
    plt.plot(prices.index, random_walk, label='Random Walk', color='orange', linestyle='--')
    plt.title(f'{ticker} Stock Prices vs. Random Walk')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.legend()
    plt.tight_layout()
    plt.show()

    # 2. Unit Root Test (ADF)
    adf_result = adfuller(prices, autolag='AIC')
    adf_stat = adf_result[0]
    p_value = adf_result[1]
    critical_values = adf_result[4]

    # Print ADF results
    print(f'\n{ticker} Unit Root Test (ADF):')
    print(f'ADF Statistic: {adf_stat:.4f}')
    print(f'p-value: {p_value:.4f}')
    print('Critical Values:')
    for key, value in critical_values.items():
        print(f'  {key}: {value:.4f}')
    print(f'Result: {"Stationary" if p_value < 0.05 else "Non-Stationary"}')

    # 3. Correlogram (Autocorrelation Plot)
    plt.figure(figsize=(10, 6))
    plot_acf(prices, lags=40, title=f'{ticker} Autocorrelation Plot')
    plt.tight_layout()
    plt.show()

    # 4. Compute autocorrelation for conclusion
    acf_values = acf(prices, nlags=40, fft=False)
    significant_lags = len([x for x in acf_values[1:] if abs(x) > 0.2])  # Skip lag 0

    # 5. Conclusion for the Equity
    print(f'\n{ticker} Conclusion:')
    print(f'- Random Walk: The actual prices {"deviate significantly" if std_return > 0.02 else "somewhat follow"} the random walk, suggesting {"market-driven trends" if std_return > 0.02 else "partial randomness"} in price movements.')
    print(f'- Unit Root: The {"non-stationary" if p_value >= 0.05 else "stationary"} nature (p-value: {p_value:.4f}) indicates prices {"trend over time, making long-term prediction challenging" if p_value >= 0.05 else "revert to a mean, aiding predictability"}.')
    print(f'- Correlogram: Autocorrelation is high at lag 1, {"with significant persistence for several lags, suggesting short-term momentum" if significant_lags > 5 else "fading quickly, indicating limited momentum"}.')
    print(f'- Investment Insight: {ticker} is {"volatile with trend-driven opportunities" if std_return > 0.02 and p_value >= 0.05 else "stable with potential short-term predictability" if p_value < 0.05 else "stable but trending, suited for long-term holding"}.')