# -*- coding: utf-8 -*-
"""2.2 Pruebas de ra√≠z unitaria

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zz5It-XHU_KhMlGQxhZELSXS1kf18xC0
"""

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf

# Set random seed for reproducibility
np.random.seed(42)

# Step 1: Download stock data from Yahoo Finance
tickers = ['MSFT', 'AMZN', 'GOOGL']
start_date = '2019-11-29'
end_date = '2025-04-08'  # Up to the current date

data = yf.download(tickers, start=start_date, end=end_date)['Close']  # Use 'Close' for adjusted prices

# Step 2: Simulate Random Walks based on historical returns
def simulate_random_walk(price_series, steps=300):
    returns = price_series.pct_change().dropna()  # Daily returns
    mean_return = returns.mean()
    std_return = returns.std()

    # Generate random walk
    random_steps = np.random.normal(mean_return, std_return, steps)
    random_walk = np.cumprod(1 + random_steps) * price_series.iloc[0]  # Start from initial price
    return random_walk

# Simulate random walks and store results
random_walks = {}
for ticker in tickers:
    random_walks[ticker] = simulate_random_walk(data[ticker])

# Step 3: Unit Root Test (Augmented Dickey-Fuller Test) with Conclusion
def unit_root_test(series, ticker):
    result = adfuller(series.dropna())
    print(f'\nUnit Root Test (ADF) for {ticker}:')
    print(f'ADF Statistic: {result[0]:.4f}')
    print(f'p-value: {result[1]:.4f}')
    print('Critical Values:')
    for key, value in result[4].items():
        print(f'   {key}: {value:.4f}')
    if result[1] < 0.05:
        print(f'{ticker} is likely stationary (reject null hypothesis).')
        conclusion = f"Conclusion: {ticker}'s price series appears stationary, suggesting it may revert to a mean over time, unlike a pure random walk."
    else:
        print(f'{ticker} is likely non-stationary (fail to reject null hypothesis).')
        conclusion = f"Conclusion: {ticker}'s price series is non-stationary, consistent with a random walk where price changes are unpredictable and trend-driven."
    print(conclusion)

# Step 4: Plotting and Analysis with Conclusions
for ticker in tickers:
    # Random Walk Plot
    plt.figure(figsize=(10, 5))
    plt.plot(random_walks[ticker], label=f'{ticker} Random Walk', color='blue')
    plt.title(f'{ticker} Random Walk Simulation (300 Steps)')
    plt.xlabel('Steps')
    plt.ylabel('Price')
    plt.legend()
    plt.grid(True)
    plt.show()
    # Random Walk Conclusion
    rw_trend = "upward" if random_walks[ticker][-1] > random_walks[ticker][0] else "downward"
    rw_volatility = np.std(random_walks[ticker])
    print(f"\nRandom Walk Conclusion for {ticker}:")
    print(f"The simulated random walk for {ticker} shows a {rw_trend} trajectory over 300 steps, with a volatility (std dev) of {rw_volatility:.2f}. "
          f"This reflects the stock's historical return distribution, but lacks the real-world trends and events seen in actual prices.")

    # Actual Stock Price Plot
    plt.figure(figsize=(10, 5))
    plt.plot(data[ticker], label=f'{ticker} Actual Price', color='green')
    plt.title(f'{ticker} Actual Stock Price (Nov 29, 2019 - Apr 08, 2025)')
    plt.xlabel('Date')
    plt.ylabel('Price')
    plt.legend()
    plt.grid(True)
    plt.show()
    # Actual Price Conclusion
    price_change = ((data[ticker][-1] - data[ticker][0]) / data[ticker][0]) * 100
    trend = "growth" if price_change > 0 else "decline"
    print(f"\nActual Price Conclusion for {ticker}:")
    print(f"From Nov 29, 2019, to Apr 08, 2025, {ticker}'s price shows a {trend} of {price_change:.2f}%. "
          f"Unlike the random walk, this reflects market dynamics, investor sentiment, and company performance.")

    # Correlogram Plot
    plt.figure(figsize=(10, 5))
    plot_acf(data[ticker].dropna(), lags=20, title=f'{ticker} Correlogram')
    plt.show()
    # Correlogram Conclusion
    acf_values = pd.Series(data[ticker]).autocorr(lag=1)  # First lag autocorrelation
    decay = "slow" if acf_values > 0.9 else "moderate"
    print(f"\nCorrelogram Conclusion for {ticker}:")
    print(f"The correlogram for {ticker} shows a {decay} decay in autocorrelation (first lag: {acf_values:.2f}), "
          f"indicating strong persistence in price movements, typical of a non-stationary series like a random walk with drift.")

# Run Unit Root Tests with Conclusions
for ticker in tickers:
    unit_root_test(data[ticker], ticker)